<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dragon Ball Sparking Zero Match Builder</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #ff6b00, #ff8c00, #ffa500);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      }

      h1 {
        text-align: center;
        color: #ff6b00;
        margin-bottom: 30px;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      .btn {
        padding: 12px 24px;
        border: none;
        border-radius: 25px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn-primary {
        background: linear-gradient(45deg, #ff6b00, #ff8c00);
        color: white;
      }

      .btn-primary:hover {
        box-shadow: 0 8px 16px rgba(255, 107, 0, 0.3);
      }

      .btn-secondary {
        background: linear-gradient(45deg, #4caf50, #45a049);
        color: white;
      }

      .btn-secondary:hover {
        box-shadow: 0 8px 16px rgba(76, 175, 80, 0.3);
      }

      .btn-danger {
        background: linear-gradient(45deg, #f44336, #da190b);
        color: white;
      }

      .btn-danger:hover {
        box-shadow: 0 8px 16px rgba(244, 67, 54, 0.3);
      }

      .btn-info {
        background: linear-gradient(45deg, #2196f3, #1976d2);
        color: white;
      }

      .btn-info:hover {
        box-shadow: 0 8px 16px rgba(33, 150, 243, 0.3);
      }

      .btn-warning {
        background: linear-gradient(45deg, #ff9800, #f57c00);
        color: white;
      }

      .btn-warning:hover {
        box-shadow: 0 8px 16px rgba(255, 152, 0, 0.3);
      }

      .btn-small {
        padding: 6px 12px;
        font-size: 12px;
        border-radius: 15px;
        margin: 2px;
      }

      .matches-container {
        display: flex;
        flex-direction: column;
        gap: 30px;
      }

      .match-card {
        background: white;
        border-radius: 15px;
        padding: 25px;
        box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
        border: 3px solid #ff6b00;
      }

      .match-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #ff6b00;
        flex-wrap: wrap;
        gap: 10px;
      }

      .match-title {
        font-size: 1.5em;
        color: #ff6b00;
        font-weight: bold;
      }

      .match-controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .teams-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 20px;
      }

      .team {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border-radius: 12px;
        padding: 20px;
        border: 2px solid #ff6b00;
      }

      .team-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
        gap: 10px;
      }

      .team-title {
        font-size: 1.2em;
        font-weight: bold;
        color: #ff6b00;
        text-transform: uppercase;
      }

      .editable-title {
        background: transparent;
        border: 1px solid transparent;
        color: #ff6b00;
        font-weight: bold;
        font-size: inherit;
        padding: 4px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .editable-title:hover {
        background: rgba(255, 107, 0, 0.1);
        border-color: #ff6b00;
      }

      .editable-title:focus {
        outline: none;
        background: white;
        border-color: #ff6b00;
        cursor: text;
      }

      .match-title .editable-title {
        font-size: 1.5em;
        text-align: center;
        min-width: 200px;
      }

      .team-title .editable-title {
        font-size: 1.2em;
        text-transform: uppercase;
        min-width: 120px;
      }

      .team-controls {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
      }

      .character-slot {
        margin-bottom: 15px;
        padding: 15px;
        background: white;
        border-radius: 8px;
        border: 1px solid #ddd;
      }

      .character-slot.filled {
        border-color: #ff6b00;
        background: linear-gradient(135deg, #fff5f0, #ffe5d9);
      }

      .character-select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        margin-bottom: 10px;
      }

      .character-select:focus {
        outline: none;
        border-color: #ff6b00;
      }

      .searchbar-container {
        position: relative;
        width: 100%;
        margin-bottom: 10px;
      }

      .searchbar {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 5px;
        font-size: 14px;
        background: white;
      }

      .searchbar:focus {
        outline: none;
        border-color: #ff6b00;
      }

      .searchbar-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-top: none;
        border-radius: 0 0 5px 5px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
      }

      .searchbar-dropdown.show {
        display: block;
      }

      .searchbar-option {
        padding: 8px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        font-size: 14px;
      }

      .searchbar-option:hover {
        background: #f8f9fa;
      }

      .searchbar-option.selected {
        background: #ff6b00;
        color: white;
      }

      .searchbar-option:last-child {
        border-bottom: none;
      }

      .item-searchbar {
        padding: 4px;
        border: 1px solid #ddd;
        border-radius: 3px;
        font-size: 12px;
        width: 100%;
      }

      .item-searchbar:focus {
        outline: none;
        border-color: #ff6b00;
      }

      .item-searchbar.ai-item {
        background: linear-gradient(135deg, #e3f2fd, #bbdefb);
        border-color: #2196f3;
      }

      .item-searchbar.costume-item {
        background: linear-gradient(135deg, #f3e5f5, #e1bee7);
        border-color: #9c27b0;
        font-weight: bold;
      }

      .item-searchbar-container {
        position: relative;
      }

      .item-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-top: none;
        border-radius: 0 0 3px 3px;
        max-height: 150px;
        overflow-y: auto;
        z-index: 999;
        display: none;
      }

      .item-dropdown.show {
        display: block;
      }

      .item-option {
        padding: 6px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        font-size: 12px;
      }

      .item-option:hover {
        background: #f8f9fa;
      }

      .item-option.selected {
        background: #ff6b00;
        color: white;
      }

      .item-option:last-child {
        border-bottom: none;
      }

      .character-and-costume {
        display: grid;
        grid-template-columns: 2fr 1fr;
        gap: 10px;
        margin-bottom: 10px;
      }

      .items-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 8px;
        margin-top: 10px;
      }

      .character-info {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 10px;
        flex-direction: column;
        gap: 10px;
      }

      .character-name {
        font-weight: bold;
        color: #ff6b00;
      }

      .remove-character {
        background: #f44336;
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
        font-size: 12px;
        align-self: flex-end;
      }

      .remove-character:hover {
        background: #da190b;
      }

      .export-controls {
        text-align: center;
        margin-top: 30px;
        padding-top: 20px;
        border-top: 2px solid #ff6b00;
      }

      .file-input {
        margin: 10px;
        padding: 10px;
        border: 2px dashed #ff6b00;
        border-radius: 8px;
        background: #fff5f0;
      }

      .file-input-group {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .loading {
        text-align: center;
        padding: 20px;
        color: #ff6b00;
        font-size: 18px;
      }

      .error {
        background: #ffebee;
        color: #c62828;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border: 1px solid #ef5350;
      }

      .success {
        background: #e8f5e8;
        color: #2e7d32;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        border: 1px solid #4caf50;
      }

      .hidden-file-input {
        display: none;
      }

      @media (max-width: 768px) {
        .teams-container {
          grid-template-columns: 1fr;
        }

        .controls {
          flex-direction: column;
          align-items: center;
        }

        .items-container {
          grid-template-columns: 1fr;
        }

        .file-input-group {
          grid-template-columns: 1fr;
        }

        .match-header {
          flex-direction: column;
          align-items: center;
          text-align: center;
        }

        .team-header {
          flex-direction: column;
          align-items: center;
          text-align: center;
        }

        .character-and-costume {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>🐉 Dragon Ball Sparking Zero Match Builder</h1>

      <div class="file-input-group">
        <div class="file-input">
          <label for="match-setup-file">Import Match Setup JSON:</label>
          <input type="file" id="match-setup-file" accept=".json" />
        </div>

        <div class="file-input">
          <label for="item-setup-file">Import Item Setup JSON:</label>
          <input type="file" id="item-setup-file" accept=".json" />
        </div>
      </div>

      <div class="loading" id="loading" style="display: none">
        Loading data...
      </div>
      <div class="error" id="error" style="display: none"></div>
      <div class="success" id="success" style="display: none"></div>

      <div class="controls" id="controls" style="display: none">
        <button class="btn btn-primary" onclick="addMatch()">Add Match</button>
        <button class="btn btn-secondary" onclick="exportMatches()">
          Export All Matches
        </button>
        <button class="btn btn-info" onclick="importFromJSON()">
          Import from JSON
        </button>
        <button class="btn btn-danger" onclick="clearAllMatches()">
          Clear All
        </button>
      </div>

      <div class="matches-container" id="matches-container"></div>

      <div class="export-controls" id="export-controls" style="display: none">
        <p>
          Export will generate JSON files for matches, teams, or complete setups
        </p>
      </div>

      <!-- Hidden file inputs for specific imports -->
      <input
        type="file"
        id="specific-match-import"
        class="hidden-file-input"
        accept=".json"
      />
      <input
        type="file"
        id="specific-team-import"
        class="hidden-file-input"
        accept=".json"
      />
    </div>

    <script>
      let characters = [];
      let capsules = [];
      let costumes = [];
      let aiItems = [];
      let matches = [];
      let matchCounter = 1;
      let currentSelection = -1;
      let currentDropdown = null;
      let pendingMatchSetup = null;
      let pendingItemSetup = null;
      let pendingImportTarget = null; // For specific imports

      // File loading
      document
        .getElementById("match-setup-file")
        .addEventListener("change", loadMatchSetupFile);
      document
        .getElementById("item-setup-file")
        .addEventListener("change", loadItemSetupFile);
      document
        .getElementById("specific-match-import")
        .addEventListener("change", handleSpecificMatchImport);
      document
        .getElementById("specific-team-import")
        .addEventListener("change", handleSpecificTeamImport);

      // Auto-load CSV files from same directory
      window.addEventListener("DOMContentLoaded", function () {
        document.getElementById("loading").style.display = "block";
        loadCSVFiles();
      });

      async function loadCSVFiles() {
        try {
          // Load character list
          await loadCSVFromFile("characters.csv", parseCharacterCSV);
          // Load capsule list (which now includes costumes)
          await loadCSVFromFile("capsules.csv", parseCapsuleCSV);
        } catch (error) {
          showError(
            "Error loading CSV files. Make sure 'characters.csv' and 'capsules.csv' are in the same folder as this HTML file. " +
              error.message
          );
        }
      }

      async function loadCSVFromFile(filename, parseFunction) {
        try {
          const response = await fetch(filename);
          if (!response.ok) {
            throw new Error(
              `Failed to load ${filename}: ${response.status} ${response.statusText}`
            );
          }
          const text = await response.text();
          parseFunction(text);
        } catch (error) {
          throw new Error(`Could not load ${filename}: ${error.message}`);
        }
      }

      function parseCharacterCSV(text) {
        const lines = text.split("\n");
        characters = [];

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line) {
            const [name, id] = line.split(",");
            if (name && id) {
              characters.push({
                name: name.replace(/"/g, "").trim(),
                id: id.replace(/"/g, "").trim(),
              });
            }
          }
        }

        showSuccess(
          `Loaded ${characters.length} characters from characters.csv`
        );
        checkDataLoaded();
      }

      function parseCapsuleCSV(text) {
        const lines = text.split("\n");
        capsules = [];
        costumes = [];
        aiItems = [];

        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line) {
            const parts = line.split(",");
            if (parts.length >= 3) {
              const item = {
                name: parts[0].replace(/"/g, "").trim(),
                id: parts[1].replace(/"/g, "").trim(),
                type: parts[2].replace(/"/g, "").trim(),
              };

              // Add exclusive for field if it exists (for costumes)
              if (parts.length >= 4) {
                item.exclusiveFor = parts[3].replace(/"/g, "").trim();
              }

              if (item.type === "Capsule") {
                capsules.push(item);
              } else if (item.type === "Costume") {
                costumes.push(item);
              } else if (item.type === "AI") {
                aiItems.push(item);
              }
            }
          }
        }

        showSuccess(
          `Loaded ${capsules.length} capsules, ${costumes.length} costumes, and ${aiItems.length} AI items from capsules.csv`
        );
        checkDataLoaded();
      }

      async function loadMatchSetupFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          pendingMatchSetup = JSON.parse(text);
          showSuccess(
            "Match Setup JSON loaded. Click 'Import from JSON' to apply."
          );
          checkImportReady();
        } catch (error) {
          showError("Error loading Match Setup file: " + error.message);
        }
      }

      async function loadItemSetupFile(event) {
        const file = event.target.files[0];
        if (!file) return;

        try {
          const text = await file.text();
          pendingItemSetup = JSON.parse(text);
          showSuccess(
            "Item Setup JSON loaded. Click 'Import from JSON' to apply."
          );
          checkImportReady();
        } catch (error) {
          showError("Error loading Item Setup file: " + error.message);
        }
      }

      async function handleSpecificMatchImport(event) {
        const file = event.target.files[0];
        if (!file || !pendingImportTarget) return;

        try {
          const text = await file.text();
          const data = JSON.parse(text);

          if (data.match && data.items) {
            const { matchId } = pendingImportTarget;
            const match = matches.find((m) => m.id === matchId);

            if (match) {
              // Replace match data
              match.team1 = data.match.team1 || [];
              match.team2 = data.match.team2 || [];

              // Import names if available
              if (data.match.name) {
                match.name = data.match.name;
              }
              if (data.match.team1Name) {
                match.team1Name = data.match.team1Name;
              }
              if (data.match.team2Name) {
                match.team2Name = data.match.team2Name;
              }

              renderMatches();
              showSuccess(
                `Successfully imported match ${match.name || matchId} data.`
              );
            }
          } else {
            showError("Invalid match file format.");
          }
        } catch (error) {
          showError("Error importing match: " + error.message);
        }

        pendingImportTarget = null;
        event.target.value = "";
      }

      async function handleSpecificTeamImport(event) {
        const file = event.target.files[0];
        if (!file || !pendingImportTarget) return;

        try {
          const text = await file.text();
          const data = JSON.parse(text);

          if (data.team && data.items) {
            const { matchId, teamName } = pendingImportTarget;
            const match = matches.find((m) => m.id === matchId);

            if (match) {
              // Replace team data
              match[teamName] = data.team || [];

              // Import team name if available
              if (data.teamDisplayName) {
                match[teamName + "Name"] = data.teamDisplayName;
              }

              renderMatches();
              showSuccess(
                `Successfully imported ${
                  match[teamName + "Name"] || teamName
                } data for ${match.name || `match ${matchId}`}.`
              );
            }
          } else {
            showError("Invalid team file format.");
          }
        } catch (error) {
          showError("Error importing team: " + error.message);
        }

        pendingImportTarget = null;
        event.target.value = "";
      }

      function checkImportReady() {
        if (
          pendingMatchSetup &&
          pendingItemSetup &&
          characters.length > 0 &&
          (capsules.length > 0 || aiItems.length > 0)
        ) {
          document.querySelector(".btn-info").style.display = "inline-block";
        }
      }

      function checkDataLoaded() {
        if (
          characters.length > 0 &&
          (capsules.length > 0 || aiItems.length > 0 || costumes.length > 0)
        ) {
          document.getElementById("controls").style.display = "flex";
          document.getElementById("export-controls").style.display = "block";
          document.getElementById("loading").style.display = "none";
          hideError();
          checkImportReady();
        }
      }

      function showError(message) {
        document.getElementById("error").textContent = message;
        document.getElementById("error").style.display = "block";
        hideSuccess();
      }

      function hideError() {
        document.getElementById("error").style.display = "none";
      }

      function showSuccess(message) {
        document.getElementById("success").textContent = message;
        document.getElementById("success").style.display = "block";
        hideError();
      }

      function hideSuccess() {
        document.getElementById("success").style.display = "none";
      }

      function updateMatchName(matchId, newName) {
        const match = matches.find((m) => m.id === matchId);
        if (match) {
          match.name = newName.trim() || `Match ${matchId}`;
        }
      }

      function updateTeamName(matchId, teamName, newName) {
        const match = matches.find((m) => m.id === matchId);
        if (match) {
          if (teamName === "team1") {
            match.team1Name = newName.trim() || "Team 1";
          } else if (teamName === "team2") {
            match.team2Name = newName.trim() || "Team 2";
          }
        }
      }

      function exportSpecificMatch(matchId) {
        const match = matches.find((m) => m.id === matchId);
        if (!match) return;

        const matchData = {
          match: {
            id: match.id,
            name: match.name || `Match ${match.id}`,
            team1: match.team1,
            team2: match.team2,
            team1Name: match.team1Name || "Team 1",
            team2Name: match.team2Name || "Team 2",
          },
          items: generateItemsForMatch(match),
        };

        const filename = `${(match.name || `Match_${match.id}`).replace(
          /[^a-z0-9]/gi,
          "_"
        )}.json`;
        downloadFile(filename, JSON.stringify(matchData, null, 2));
        showSuccess(
          `Exported ${match.name || `Match ${match.id}`} to ${filename}`
        );
      }

      function exportSpecificTeam(matchId, teamName) {
        const match = matches.find((m) => m.id === matchId);
        if (!match) return;

        const teamData = {
          team: match[teamName],
          items: generateItemsForTeam(match, teamName),
          matchId: matchId,
          teamName: teamName,
          teamDisplayName:
            match[teamName + "Name"] ||
            (teamName === "team1" ? "Team 1" : "Team 2"),
        };

        const matchDisplayName = (match.name || `Match_${match.id}`).replace(
          /[^a-z0-9]/gi,
          "_"
        );
        const teamDisplayName = (match[teamName + "Name"] || teamName).replace(
          /[^a-z0-9]/gi,
          "_"
        );
        const filename = `${matchDisplayName}_${teamDisplayName}.json`;
        downloadFile(filename, JSON.stringify(teamData, null, 2));
        showSuccess(
          `Exported ${match[teamName + "Name"] || teamName} from ${
            match.name || `Match ${match.id}`
          } to ${filename}`
        );
      }

      function importSpecificMatch(matchId) {
        pendingImportTarget = { matchId };
        document.getElementById("specific-match-import").click();
      }

      function importSpecificTeam(matchId, teamName) {
        pendingImportTarget = { matchId, teamName };
        document.getElementById("specific-team-import").click();
      }

      function generateItemsForMatch(match) {
        const items = {};
        const allCharacters = [...match.team1, ...match.team2];

        allCharacters.forEach((char) => {
          if (char.id && char.id !== "") {
            items[char.id] = {
              capsules: char.capsules,
              costume: char.costume || "",
              ai: char.ai,
            };
          }
        });

        return items;
      }

      function generateItemsForTeam(match, teamName) {
        const items = {};
        const team = match[teamName];

        team.forEach((char) => {
          if (char.id && char.id !== "") {
            items[char.id] = {
              capsules: char.capsules,
              costume: char.costume || "",
              ai: char.ai,
            };
          }
        });

        return items;
      }

      function importFromJSON() {
        if (!pendingMatchSetup || !pendingItemSetup) {
          showError(
            "Please load both Match Setup and Item Setup JSON files first."
          );
          return;
        }

        try {
          matches = [];
          matchCounter = 1;

          // Import matches from JSON
          const matchCount = pendingMatchSetup.matchCount;
          for (const matchNum in matchCount) {
            const matchData = matchCount[matchNum];
            const match = {
              id: parseInt(matchNum),
              name: `Match ${matchNum}`,
              team1: [],
              team2: [],
              team1Name: "Team 1",
              team2Name: "Team 2",
            };

            // Import team 1 (com1)
            matchData.targetTeaming.com1.teamMembers.forEach((member) => {
              if (member.key !== "None") {
                const character = characters.find((c) => c.id === member.key);
                if (character) {
                  match.team1.push({
                    name: character.name,
                    id: character.id,
                    capsules: new Array(7).fill(""),
                    costume: "",
                    ai: "",
                  });
                }
              }
            });

            // Import team 2 (com2)
            matchData.targetTeaming.com2.teamMembers.forEach((member) => {
              if (member.key !== "None") {
                const character = characters.find((c) => c.id === member.key);
                if (character) {
                  match.team2.push({
                    name: character.name,
                    id: character.id,
                    capsules: new Array(7).fill(""),
                    costume: "",
                    ai: "",
                  });
                }
              }
            });

            matches.push(match);
          }

          // Import item setups
          const itemCount = pendingItemSetup.matchCount;
          for (const matchNum in itemCount) {
            const matchIndex = parseInt(matchNum) - 1;
            const match = matches[matchIndex];
            if (!match) continue;

            const customize = itemCount[matchNum].customize;

            for (const charKey in customize) {
              const characterId = charKey
                .replace('(Key="', "")
                .replace('")', "");
              const targetSettings = customize[charKey].targetSettings;

              // Find character in both teams
              const allCharacters = [...match.team1, ...match.team2];
              const character = allCharacters.find((c) => c.id === characterId);

              if (character) {
                // Look for team1 (index 2) or team2 (index 3) equipment
                const team1Equipment = targetSettings[2]?.equipItems || [];
                const team2Equipment = targetSettings[3]?.equipItems || [];

                let equipItems = [];
                if (team1Equipment.some((item) => item.key !== "None")) {
                  equipItems = team1Equipment;
                } else if (team2Equipment.some((item) => item.key !== "None")) {
                  equipItems = team2Equipment;
                }

                if (equipItems.length > 0) {
                  // Process equipment items
                  equipItems.forEach((item, index) => {
                    if (item.key !== "None") {
                      // Check if it's a costume
                      const costume = costumes.find(c => c.id === item.key);
                      if (costume) {
                        character.costume = item.key;
                      } else if (index < 7) {
                        // First 7 non-costume items are capsules
                        character.capsules[index] = item.key;
                      } else {
                        // Remaining items are AI
                        character.ai = item.key;
                      }
                    }
                  });
                }
              }
            }
          }

          // Update match counter
          matchCounter = Math.max(...matches.map((m) => m.id)) + 1;

          renderMatches();
          showSuccess(
            `Successfully imported ${matches.length} matches from JSON files.`
          );

          // Clear pending data
          pendingMatchSetup = null;
          pendingItemSetup = null;
        } catch (error) {
          showError("Error importing from JSON: " + error.message);
        }
      }

      function addMatch() {
        const match = {
          id: matchCounter++,
          name: `Match ${matchCounter - 1}`,
          team1: [],
          team2: [],
          team1Name: "Team 1",
          team2Name: "Team 2",
        };

        matches.push(match);
        renderMatches();
      }

      function duplicateMatch(matchId) {
        const originalMatch = matches.find((m) => m.id === matchId);
        if (!originalMatch) return;

        // Deep clone the match
        const duplicatedMatch = {
          id: matchCounter++,
          name: `${originalMatch.name} (Copy)`,
          team1Name: originalMatch.team1Name || "Team 1",
          team2Name: originalMatch.team2Name || "Team 2",
          team1: originalMatch.team1.map((char) => ({
            name: char.name,
            id: char.id,
            capsules: [...char.capsules],
            costume: char.costume || "",
            ai: char.ai,
          })),
          team2: originalMatch.team2.map((char) => ({
            name: char.name,
            id: char.id,
            capsules: [...char.capsules],
            costume: char.costume || "",
            ai: char.ai,
          })),
        };

        matches.push(duplicatedMatch);
        renderMatches();
      }

      function removeMatch(matchId) {
        matches = matches.filter((m) => m.id !== matchId);
        renderMatches();
      }

      function clearAllMatches() {
        matches = [];
        matchCounter = 1;
        renderMatches();
      }

      function renderMatches() {
        const container = document.getElementById("matches-container");
        container.innerHTML = "";

        matches.forEach((match) => {
          const matchDiv = document.createElement("div");
          matchDiv.className = "match-card";
          matchDiv.innerHTML = `
                    <div class="match-header">
                        <div class="match-title">
                            <input type="text" class="editable-title" value="${
                              match.name || `Match ${match.id}`
                            }" 
                                   onchange="updateMatchName(${
                                     match.id
                                   }, this.value)"
                                   onblur="this.onchange()"
                                   title="Click to edit match name">
                        </div>
                        <div class="match-controls">
                            <button class="btn btn-small btn-secondary" onclick="duplicateMatch(${
                              match.id
                            })">Duplicate</button>
                            <button class="btn btn-small btn-warning" onclick="exportSpecificMatch(${
                              match.id
                            })">Export Match</button>
                            <button class="btn btn-small btn-info" onclick="importSpecificMatch(${
                              match.id
                            })">Import Match</button>
                            <button class="btn btn-small btn-danger" onclick="removeMatch(${
                              match.id
                            })">Remove</button>
                        </div>
                    </div>
                    <div class="teams-container">
                        <div class="team">
                            <div class="team-header">
                                <div class="team-title">
                                    <input type="text" class="editable-title" value="${
                                      match.team1Name || "Team 1"
                                    }" 
                                           onchange="updateTeamName(${
                                             match.id
                                           }, 'team1', this.value)"
                                           onblur="this.onchange()"
                                           title="Click to edit team name">
                                </div>
                                <div class="team-controls">
                                    <button class="btn btn-small btn-warning" onclick="exportSpecificTeam(${
                                      match.id
                                    }, 'team1')">Export Team</button>
                                    <button class="btn btn-small btn-info" onclick="importSpecificTeam(${
                                      match.id
                                    }, 'team1')">Import Team</button>
                                </div>
                            </div>
                            <div id="team1-${match.id}"></div>
                            <button class="btn btn-primary" onclick="addCharacter(${
                              match.id
                            }, 'team1')" style="width: 100%; margin-top: 10px;">Add Character</button>
                        </div>
                        <div class="team">
                            <div class="team-header">
                                <div class="team-title">
                                    <input type="text" class="editable-title" value="${
                                      match.team2Name || "Team 2"
                                    }" 
                                           onchange="updateTeamName(${
                                             match.id
                                           }, 'team2', this.value)"
                                           onblur="this.onchange()"
                                           title="Click to edit team name">
                                </div>
                                <div class="team-controls">
                                    <button class="btn btn-small btn-warning" onclick="exportSpecificTeam(${
                                      match.id
                                    }, 'team2')">Export Team</button>
                                    <button class="btn btn-small btn-info" onclick="importSpecificTeam(${
                                      match.id
                                    }, 'team2')">Import Team</button>
                                </div>
                            </div>
                            <div id="team2-${match.id}"></div>
                            <button class="btn btn-primary" onclick="addCharacter(${
                              match.id
                            }, 'team2')" style="width: 100%; margin-top: 10px;">Add Character</button>
                        </div>
                    </div>
                `;
          container.appendChild(matchDiv);

          renderTeam(match.id, "team1", match.team1);
          renderTeam(match.id, "team2", match.team2);
        });
      }

      function renderTeam(matchId, teamName, team) {
        const container = document.getElementById(`${teamName}-${matchId}`);
        container.innerHTML = "";

        team.forEach((character, index) => {
          const charDiv = document.createElement("div");
          charDiv.className = "character-slot filled";
          charDiv.innerHTML = `
                    <div class="character-info">
                        <div class="character-and-costume">
                            <div class="searchbar-container">
                                <input type="text" class="searchbar" placeholder="Search character..." 
                                       value="${
                                         character.name === "Select Character"
                                           ? ""
                                           : character.name
                                       }"
                                       onkeyup="filterCharacters(${matchId}, '${teamName}', ${index}, this.value)"
                                       onfocus="showCharacterDropdown(${matchId}, '${teamName}', ${index})"
                                       onblur="hideCharacterDropdown(${matchId}, '${teamName}', ${index})">
                                <div class="searchbar-dropdown" id="char-dropdown-${matchId}-${teamName}-${index}">
                                    ${generateCharacterOptions(character.id)}
                                </div>
                            </div>
                            <div class="item-searchbar-container">
                                <input type="text" class="item-searchbar costume-item" placeholder="Costume" 
                                       value="${getCostumeName(character.costume)}"
                                       onkeyup="filterItems(${matchId}, '${teamName}', ${index}, 'costume', 0, this.value)"
                                       onfocus="showItemDropdown(${matchId}, '${teamName}', ${index}, 'costume', 0)"
                                       onblur="hideItemDropdown(${matchId}, '${teamName}', ${index}, 'costume', 0)">
                                <div class="item-dropdown" id="item-dropdown-${matchId}-${teamName}-${index}-costume-0">
                                    ${generateCostumeOptions(character.name, character.costume)}
                                </div>
                            </div>
                        </div>
                        <button class="remove-character" onclick="removeCharacter(${matchId}, '${teamName}', ${index})">×</button>
                    </div>
                    <div class="items-container">
                        ${generateItemSelects(
                          matchId,
                          teamName,
                          index,
                          character
                        )}
                    </div>
                `;
          container.appendChild(charDiv);
        });
      }

      function getCostumeName(costumeId) {
        if (!costumeId) return "";
        const costume = costumes.find(c => c.id === costumeId);
        return costume ? costume.name : "";
      }

      function generateCostumeOptions(characterName, selectedId) {
        // Filter costumes for the specific character
        const characterCostumes = costumes.filter(costume => 
          costume.exclusiveFor === characterName
        );
        
        let options = '<div class="item-option" onclick="selectItem(event, \'\', \'\')" data-id="" data-name="">Default</div>';
        
        options += characterCostumes
          .map(
            (costume) => `
                <div class="item-option ${
                  selectedId === costume.id ? "selected" : ""
                }" 
                     onclick="selectItem(event, '${costume.id}', '${costume.name}')"
                     data-id="${costume.id}" data-name="${costume.name}">
                    ${costume.name}
                </div>
            `
          )
          .join("");
          
        if (characterCostumes.length === 0) {
          options += '<div class="item-option">No costumes available</div>';
        }
        
        return options;
      }

      function generateItemSelects(matchId, teamName, charIndex, character) {
        let html = "";

        // 7 Capsule slots
        for (let i = 0; i < 7; i++) {
          const selectedId = character.capsules[i] || "";
          const selectedName = selectedId
            ? capsules.find((c) => c.id === selectedId)?.name || ""
            : "";
          html += `
                    <div class="item-searchbar-container">
                        <input type="text" class="item-searchbar" placeholder="Capsule ${
                          i + 1
                        }"
                               value="${selectedName}"
                               onkeyup="filterItems(${matchId}, '${teamName}', ${charIndex}, 'capsules', ${i}, this.value)"
                               onfocus="showItemDropdown(${matchId}, '${teamName}', ${charIndex}, 'capsules', ${i})"
                               onblur="hideItemDropdown(${matchId}, '${teamName}', ${charIndex}, 'capsules', ${i})">
                        <div class="item-dropdown" id="item-dropdown-${matchId}-${teamName}-${charIndex}-capsules-${i}">
                            ${generateCapsuleOptions(selectedId)}
                        </div>
                    </div>
                `;
        }

        // 1 AI slot
        const selectedAI = character.ai || "";
        const selectedAIName = selectedAI
          ? aiItems.find((a) => a.id === selectedAI)?.name || ""
          : "";
        html += `
                <div class="item-searchbar-container">
                    <input type="text" class="item-searchbar ai-item" placeholder="AI Strategy"
                           value="${selectedAIName}"
                           onkeyup="filterItems(${matchId}, '${teamName}', ${charIndex}, 'ai', 0, this.value)"
                           onfocus="showItemDropdown(${matchId}, '${teamName}', ${charIndex}, 'ai', 0)"
                           onblur="hideItemDropdown(${matchId}, '${teamName}', ${charIndex}, 'ai', 0)">
                    <div class="item-dropdown" id="item-dropdown-${matchId}-${teamName}-${charIndex}-ai-0">
                        ${generateAIOptions(selectedAI)}
                    </div>
                </div>
            `;

        return html;
      }

      function generateCapsuleOptions(selectedId) {
        let options =
          '<div class="item-option" onclick="selectItem(event, \'\', \'\')" data-id="" data-name="">None</div>';
        options += capsules
          .map(
            (cap) => `
                <div class="item-option ${
                  selectedId === cap.id ? "selected" : ""
                }" 
                     onclick="selectItem(event, '${cap.id}', '${cap.name}')"
                     data-id="${cap.id}" data-name="${cap.name}">
                    ${cap.name}
                </div>
            `
          )
          .join("");
        return options;
      }

      function generateAIOptions(selectedId) {
        let options =
          '<div class="item-option" onclick="selectItem(event, \'\', \'\')" data-id="" data-name="">None</div>';
        options += aiItems
          .map(
            (ai) => `
                <div class="item-option ${
                  selectedId === ai.id ? "selected" : ""
                }" 
                     onclick="selectItem(event, '${ai.id}', '${ai.name}')"
                     data-id="${ai.id}" data-name="${ai.name}">
                    ${ai.name}
                </div>
            `
          )
          .join("");
        return options;
      }

      function filterItems(
        matchId,
        teamName,
        charIndex,
        itemType,
        itemIndex,
        searchValue
      ) {
        const dropdown = document.getElementById(
          `item-dropdown-${matchId}-${teamName}-${charIndex}-${itemType}-${itemIndex}`
        );
        
        let items = [];
        let options = "";
        
        if (itemType === "costume") {
          // Get character name for filtering costumes
          const match = matches.find((m) => m.id === matchId);
          const character = match[teamName][charIndex];
          const characterName = character.name;
          
          items = costumes.filter(costume => costume.exclusiveFor === characterName);
          
          // If search is empty, show all costumes for this character
          const filtered = searchValue.trim() === ""
            ? items
            : items.filter((item) =>
                item.name.toLowerCase().includes(searchValue.toLowerCase())
              );

          options = '<div class="item-option" onclick="selectItem(event, \'\', \'\', `' +
            matchId + '`, `' + teamName + '`, ' + charIndex + ', `' + itemType + '`, ' + itemIndex +
            ')" data-id="" data-name="">Default</div>';

          options += filtered
            .map(
              (item) => `
                  <div class="item-option" 
                      onclick="selectItem(event, '${item.id}', '${item.name}', ${matchId}, '${teamName}', ${charIndex}, '${itemType}', ${itemIndex})"
                      data-id="${item.id}" data-name="${item.name}">
                      ${item.name}
                  </div>
              `
            )
            .join("");

          if (filtered.length === 0 && characterName && characterName !== "Select Character") {
            options += '<div class="item-option">No costumes found</div>';
          } else if (!characterName || characterName === "Select Character") {
            options = '<div class="item-option">Select character first</div>';
          }
        } else {
          // Handle capsules and AI items as before
          items = itemType === "capsules" ? capsules : aiItems;

          // If search is empty, show all items
          const filtered =
            searchValue.trim() === ""
              ? items
              : items.filter((item) =>
                  item.name.toLowerCase().includes(searchValue.toLowerCase())
                );

          options =
            "<div class=\"item-option\" onclick=\"selectItem(event, '', '', `" +
            matchId +
            "`, `" +
            teamName +
            "`, " +
            charIndex +
            ", `" +
            itemType +
            "`, " +
            itemIndex +
            ')" data-id="" data-name="">None</div>';

          options += filtered
            .map(
              (item) => `
                  <div class="item-option" 
                      onclick="selectItem(event, '${item.id}', '${item.name}', ${matchId}, '${teamName}', ${charIndex}, '${itemType}', ${itemIndex})"
                      data-id="${item.id}" data-name="${item.name}">
                      ${item.name}
                  </div>
              `
            )
            .join("");

          if (filtered.length === 0) {
            options += '<div class="item-option">No items found</div>';
          }
        }

        dropdown.innerHTML = options;
      }

      function showItemDropdown(
        matchId,
        teamName,
        charIndex,
        itemType,
        itemIndex
      ) {
        const dropdown = document.getElementById(
          `item-dropdown-${matchId}-${teamName}-${charIndex}-${itemType}-${itemIndex}`
        );
        dropdown.classList.add("show");

        // Only reset selection if switching to a different dropdown
        if (currentDropdown !== dropdown) {
          currentSelection = -1;
        }
        currentDropdown = dropdown;
      }

      function hideItemDropdown(
        matchId,
        teamName,
        charIndex,
        itemType,
        itemIndex
      ) {
        // Delay hiding to allow click events to fire
        setTimeout(() => {
          const dropdown = document.getElementById(
            `item-dropdown-${matchId}-${teamName}-${charIndex}-${itemType}-${itemIndex}`
          );
          if (dropdown) {
            dropdown.classList.remove("show");
            if (currentDropdown === dropdown) {
              currentDropdown = null;
              currentSelection = -1;
            }
          }
        }, 200);
      }

      function selectItem(
        event,
        itemId,
        itemName,
        matchId,
        teamName,
        charIndex,
        itemType,
        itemIndex
      ) {
        event.stopPropagation();

        // Find the match and update item
        const match = matches.find((m) => m.id === matchId);
        const character = match[teamName][charIndex];

        if (itemType === "capsules") {
          character.capsules[itemIndex] = itemId;
        } else if (itemType === "costume") {
          character.costume = itemId;
        } else if (itemType === "ai") {
          character.ai = itemId;
        }

        // Update the input field
        const input = event.target
          .closest(".item-searchbar-container")
          .querySelector(".item-searchbar");
        input.value = itemName;

        // Hide dropdown
        const dropdown = document.getElementById(
          `item-dropdown-${matchId}-${teamName}-${charIndex}-${itemType}-${itemIndex}`
        );
        dropdown.classList.remove("show");
      }

      function addCharacter(matchId, teamName) {
        const match = matches.find((m) => m.id === matchId);
        const team = match[teamName];

        if (team.length >= 5) {
          alert("Maximum 5 characters per team");
          return;
        }

        const character = {
          name: "Select Character",
          id: "",
          capsules: new Array(7).fill(""),
          costume: "",
          ai: "",
        };

        team.push(character);
        renderTeam(matchId, teamName, team);
      }

      function removeCharacter(matchId, teamName, charIndex) {
        const match = matches.find((m) => m.id === matchId);
        match[teamName].splice(charIndex, 1);
        renderTeam(matchId, teamName, match[teamName]);
      }

      function updateCharacterItem(
        matchId,
        teamName,
        charIndex,
        itemType,
        itemIndex,
        value
      ) {
        const match = matches.find((m) => m.id === matchId);
        const character = match[teamName][charIndex];

        if (itemType === "capsules") {
          character.capsules[itemIndex] = value;
        } else if (itemType === "costume") {
          character.costume = value;
        } else if (itemType === "ai") {
          character.ai = value;
        }

        // Update character selection
        if (itemType === "character") {
          const selectedChar = characters.find((c) => c.id === value);
          if (selectedChar) {
            character.name = selectedChar.name;
            character.id = selectedChar.id;
          }
        }
      }

      function generateCharacterOptions(selectedId) {
        return characters
          .map(
            (char) => `
                <div class="searchbar-option ${
                  selectedId === char.id ? "selected" : ""
                }" 
                     onclick="selectCharacter(event, '${char.id}', '${
              char.name
            }')"
                     data-id="${char.id}" data-name="${char.name}">
                    ${char.name}
                </div>
            `
          )
          .join("");
      }

      function filterCharacters(matchId, teamName, charIndex, searchValue) {
        const dropdown = document.getElementById(
          `char-dropdown-${matchId}-${teamName}-${charIndex}`
        );

        // If search is empty, show all characters
        const filtered =
          searchValue.trim() === ""
            ? characters
            : characters.filter((char) =>
                char.name.toLowerCase().includes(searchValue.toLowerCase())
              );

        dropdown.innerHTML = filtered
          .map(
            (char) => `
                <div class="searchbar-option" 
                    onclick="selectCharacter(event, '${char.id}', '${char.name}', ${matchId}, '${teamName}', ${charIndex})"
                    data-id="${char.id}" data-name="${char.name}">
                    ${char.name}
                </div>
            `
          )
          .join("");

        if (filtered.length === 0) {
          dropdown.innerHTML =
            '<div class="searchbar-option">No characters found</div>';
        }
      }

      function showCharacterDropdown(matchId, teamName, charIndex) {
        const dropdown = document.getElementById(
          `char-dropdown-${matchId}-${teamName}-${charIndex}`
        );
        dropdown.classList.add("show");

        // Only reset selection if switching to a different dropdown
        if (currentDropdown !== dropdown) {
          currentSelection = -1;
        }
        currentDropdown = dropdown;
      }

      function hideCharacterDropdown(matchId, teamName, charIndex) {
        // Delay hiding to allow click events to fire
        setTimeout(() => {
          const dropdown = document.getElementById(
            `char-dropdown-${matchId}-${teamName}-${charIndex}`
          );
          if (dropdown) {
            dropdown.classList.remove("show");
            if (currentDropdown === dropdown) {
              currentDropdown = null;
              currentSelection = -1;
            }
          }
        }, 200);
      }

      function selectCharacter(
        event,
        charId,
        charName,
        matchId,
        teamName,
        charIndex
      ) {
        event.stopPropagation();

        // Find the match and update character
        const match = matches.find((m) => m.id === matchId);
        const character = match[teamName][charIndex];

        character.name = charName;
        character.id = charId;
        character.costume = ""; // Reset costume when character changes

        // Update the character input field
        const input = event.target
          .closest(".character-info")
          .querySelector(".searchbar");
        input.value = charName;

        // Hide character dropdown
        const dropdown = document.getElementById(
          `char-dropdown-${matchId}-${teamName}-${charIndex}`
        );
        dropdown.classList.remove("show");

        // Update costume dropdown options for new character
        const costumeDropdown = document.getElementById(
          `item-dropdown-${matchId}-${teamName}-${charIndex}-costume-0`
        );
        if (costumeDropdown) {
          costumeDropdown.innerHTML = generateCostumeOptions(charName, "");
        }

        // Clear costume input field
        const costumeInput = event.target
          .closest(".character-info")
          .querySelector(".costume-item");
        if (costumeInput) {
          costumeInput.value = "";
        }
      }

      function updateCharacterSelection(matchId, teamName, charIndex, value) {
        const match = matches.find((m) => m.id === matchId);
        const character = match[teamName][charIndex];

        const selectedChar = characters.find((c) => c.id === value);
        if (selectedChar) {
          character.name = selectedChar.name;
          character.id = selectedChar.id;
        } else {
          character.name = "Select Character";
          character.id = "";
        }
      }

      function exportMatches() {
        if (matches.length === 0) {
          alert("No matches to export");
          return;
        }

        const matchSetup = generateMatchSetup();
        const itemSetup = generateItemSetup();

        downloadFile("MatchSetup.json", JSON.stringify(matchSetup, null, 2));
        downloadFile("ItemSetup.json", JSON.stringify(itemSetup, null, 2));
      }

      function generateMatchSetup() {
        const matchSetup = {
          matchCount: {},
        };

        matches.forEach((match, index) => {
          matchSetup.matchCount[index + 1] = {
            targetTeaming: {
              com1: {
                teamMembers: Array(5)
                  .fill()
                  .map((_, i) => ({
                    key: match.team1[i]?.id || "None",
                  })),
                comLevel: "High",
              },
              com2: {
                teamMembers: Array(5)
                  .fill()
                  .map((_, i) => ({
                    key: match.team2[i]?.id || "None",
                  })),
                comLevel: "High",
              },
              player: {
                teamMembers: Array(5)
                  .fill()
                  .map(() => ({ key: "None" })),
                comLevel: "Middle",
              },
              player2: {
                teamMembers: Array(5)
                  .fill()
                  .map(() => ({ key: "None" })),
                comLevel: "Middle",
              },
            },
          };
        });

        return matchSetup;
      }

      function generateItemSetup() {
        const itemSetup = {
          matchCount: {},
        };

        matches.forEach((match, index) => {
          itemSetup.matchCount[index + 1] = {
            customize: {},
          };

          // Process all characters from both teams
          const allCharacters = [...match.team1, ...match.team2];
          const uniqueCharacters = {};

          allCharacters.forEach((char) => {
            if (char.id && char.id !== "") {
              if (!uniqueCharacters[char.id]) {
                uniqueCharacters[char.id] = char;
              }
            }
          });

          Object.values(uniqueCharacters).forEach((char) => {
            const key = `(Key="${char.id}")`;

            // Prepare capsule items
            const capsuleItems = char.capsules
              .filter((cap) => cap !== "")
              .map((cap) => ({ key: cap }));

            // Add costume if selected
            const allItems = [];
            if (char.costume && char.costume !== "") {
              allItems.push({ key: char.costume });
            }
            allItems.push(...capsuleItems);

            // Prepare AI item
            if (char.ai && char.ai !== "") {
              allItems.push({ key: char.ai });
            }

            if (allItems.length === 0) {
              allItems.push({ key: "None" });
            }

            // Determine team assignments
            const inTeam1 = match.team1.some((t) => t.id === char.id);
            const inTeam2 = match.team2.some((t) => t.id === char.id);

            const team1Items = inTeam1 ? allItems : [{ key: "None" }];
            const team2Items = inTeam2 ? allItems : [{ key: "None" }];

            itemSetup.matchCount[index + 1].customize[key] = {
              targetSettings: [
                {
                  equipItems: [{ key: "None" }],
                  sameCharacterEquip: [],
                },
                {
                  equipItems: [{ key: "None" }],
                  sameCharacterEquip: [],
                },
                {
                  equipItems: team1Items,
                  sameCharacterEquip: [],
                },
                {
                  equipItems: team2Items,
                  sameCharacterEquip: [],
                },
              ],
            };
          });
        });

        return itemSetup;
      }

      function downloadFile(filename, content) {
        const blob = new Blob([content], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Keyboard navigation for dropdowns
      document.addEventListener("keydown", function (event) {
        if (!currentDropdown || !currentDropdown.classList.contains("show"))
          return;

        const options = currentDropdown.querySelectorAll(
          ".searchbar-option, .item-option"
        );

        switch (event.key) {
          case "ArrowDown":
            event.preventDefault();
            currentSelection = Math.min(
              currentSelection + 1,
              options.length - 1
            );
            updateSelection(options);
            break;

          case "ArrowUp":
            event.preventDefault();
            currentSelection = Math.max(currentSelection - 1, -1);
            updateSelection(options);
            break;

          case "Enter":
            event.preventDefault();
            if (currentSelection >= 0 && options[currentSelection]) {
              options[currentSelection].click();
            }
            break;

          case "Escape":
            event.preventDefault();
            hideAllDropdowns();
            break;
        }
      });

      function updateSelection(options) {
        options.forEach((option, index) => {
          option.classList.toggle("selected", index === currentSelection);
        });

        // Scroll the selected option into view
        if (currentSelection >= 0 && options[currentSelection]) {
          options[currentSelection].scrollIntoView({
            block: "nearest",
            behavior: "smooth",
          });
        }
      }

      function hideAllDropdowns() {
        document
          .querySelectorAll(".searchbar-dropdown, .item-dropdown")
          .forEach((dropdown) => {
            dropdown.classList.remove("show");
          });
        currentDropdown = null;
        currentSelection = -1;
      }
    </script>
  </body>
</html>
